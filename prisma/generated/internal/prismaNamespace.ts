
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.19.0
 * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
 */
export const prismaVersion: PrismaVersion = {
  client: "6.19.0",
  engine: "2ba551f319ab1df4bc874a89965d8b3641056773"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  ProspectiveRehabs: 'ProspectiveRehabs',
  InsuranceProvider: 'InsuranceProvider',
  ParentCompany: 'ParentCompany',
  YoutubeChannel: 'YoutubeChannel',
  YoutubeVideo: 'YoutubeVideo',
  SocialMediaProfile: 'SocialMediaProfile',
  RehabOrg: 'RehabOrg',
  RehabCampus: 'RehabCampus',
  RehabProgram: 'RehabProgram',
  LevelOfCare: 'LevelOfCare',
  DetoxService: 'DetoxService',
  MATType: 'MATType',
  Service: 'Service',
  Population: 'Population',
  Accreditation: 'Accreditation',
  Language: 'Language',
  Amenity: 'Amenity',
  Environment: 'Environment',
  SettingStyle: 'SettingStyle',
  LuxuryTier: 'LuxuryTier',
  ProgramFeature: 'ProgramFeature',
  PaymentOption: 'PaymentOption',
  InsurancePayer: 'InsurancePayer',
  Substance: 'Substance',
  RehabLevelOfCare: 'RehabLevelOfCare',
  RehabDetoxService: 'RehabDetoxService',
  RehabService: 'RehabService',
  RehabPopulation: 'RehabPopulation',
  RehabAccreditation: 'RehabAccreditation',
  RehabLanguage: 'RehabLanguage',
  RehabAmenity: 'RehabAmenity',
  RehabEnvironment: 'RehabEnvironment',
  RehabSettingStyle: 'RehabSettingStyle',
  RehabLuxuryTier: 'RehabLuxuryTier',
  RehabProgramFeatureGlobal: 'RehabProgramFeatureGlobal',
  RehabCampusAmenity: 'RehabCampusAmenity',
  RehabCampusLanguage: 'RehabCampusLanguage',
  RehabCampusPopulation: 'RehabCampusPopulation',
  RehabCampusEnvironment: 'RehabCampusEnvironment',
  RehabCampusSettingStyle: 'RehabCampusSettingStyle',
  RehabCampusLuxuryTier: 'RehabCampusLuxuryTier',
  RehabProgramDetoxService: 'RehabProgramDetoxService',
  RehabProgramMATType: 'RehabProgramMATType',
  RehabProgramService: 'RehabProgramService',
  RehabProgramPopulation: 'RehabProgramPopulation',
  RehabProgramLanguage: 'RehabProgramLanguage',
  RehabProgramAmenity: 'RehabProgramAmenity',
  RehabProgramFeature: 'RehabProgramFeature',
  RehabProgramSubstance: 'RehabProgramSubstance',
  RehabInsurancePayer: 'RehabInsurancePayer',
  RehabPaymentOption: 'RehabPaymentOption',
  OrgReview: 'OrgReview',
  OrgTestimonial: 'OrgTestimonial',
  OrgStory: 'OrgStory',
  CampusReview: 'CampusReview',
  CampusTestimonial: 'CampusTestimonial',
  CampusStory: 'CampusStory',
  ProgramReview: 'ProgramReview',
  ProgramTestimonial: 'ProgramTestimonial',
  ProgramStory: 'ProgramStory'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "prospectiveRehabs" | "insuranceProvider" | "parentCompany" | "youtubeChannel" | "youtubeVideo" | "socialMediaProfile" | "rehabOrg" | "rehabCampus" | "rehabProgram" | "levelOfCare" | "detoxService" | "mATType" | "service" | "population" | "accreditation" | "language" | "amenity" | "environment" | "settingStyle" | "luxuryTier" | "programFeature" | "paymentOption" | "insurancePayer" | "substance" | "rehabLevelOfCare" | "rehabDetoxService" | "rehabService" | "rehabPopulation" | "rehabAccreditation" | "rehabLanguage" | "rehabAmenity" | "rehabEnvironment" | "rehabSettingStyle" | "rehabLuxuryTier" | "rehabProgramFeatureGlobal" | "rehabCampusAmenity" | "rehabCampusLanguage" | "rehabCampusPopulation" | "rehabCampusEnvironment" | "rehabCampusSettingStyle" | "rehabCampusLuxuryTier" | "rehabProgramDetoxService" | "rehabProgramMATType" | "rehabProgramService" | "rehabProgramPopulation" | "rehabProgramLanguage" | "rehabProgramAmenity" | "rehabProgramFeature" | "rehabProgramSubstance" | "rehabInsurancePayer" | "rehabPaymentOption" | "orgReview" | "orgTestimonial" | "orgStory" | "campusReview" | "campusTestimonial" | "campusStory" | "programReview" | "programTestimonial" | "programStory"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    ProspectiveRehabs: {
      payload: Prisma.$ProspectiveRehabsPayload<ExtArgs>
      fields: Prisma.ProspectiveRehabsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProspectiveRehabsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProspectiveRehabsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>
        }
        findFirst: {
          args: Prisma.ProspectiveRehabsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProspectiveRehabsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>
        }
        findMany: {
          args: Prisma.ProspectiveRehabsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>[]
        }
        create: {
          args: Prisma.ProspectiveRehabsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>
        }
        createMany: {
          args: Prisma.ProspectiveRehabsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProspectiveRehabsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>[]
        }
        delete: {
          args: Prisma.ProspectiveRehabsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>
        }
        update: {
          args: Prisma.ProspectiveRehabsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>
        }
        deleteMany: {
          args: Prisma.ProspectiveRehabsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProspectiveRehabsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProspectiveRehabsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>[]
        }
        upsert: {
          args: Prisma.ProspectiveRehabsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProspectiveRehabsPayload>
        }
        aggregate: {
          args: Prisma.ProspectiveRehabsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProspectiveRehabs>
        }
        groupBy: {
          args: Prisma.ProspectiveRehabsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProspectiveRehabsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProspectiveRehabsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProspectiveRehabsCountAggregateOutputType> | number
        }
      }
    }
    InsuranceProvider: {
      payload: Prisma.$InsuranceProviderPayload<ExtArgs>
      fields: Prisma.InsuranceProviderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InsuranceProviderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InsuranceProviderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
        }
        findFirst: {
          args: Prisma.InsuranceProviderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InsuranceProviderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
        }
        findMany: {
          args: Prisma.InsuranceProviderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>[]
        }
        create: {
          args: Prisma.InsuranceProviderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
        }
        createMany: {
          args: Prisma.InsuranceProviderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InsuranceProviderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>[]
        }
        delete: {
          args: Prisma.InsuranceProviderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
        }
        update: {
          args: Prisma.InsuranceProviderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
        }
        deleteMany: {
          args: Prisma.InsuranceProviderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InsuranceProviderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InsuranceProviderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>[]
        }
        upsert: {
          args: Prisma.InsuranceProviderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
        }
        aggregate: {
          args: Prisma.InsuranceProviderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInsuranceProvider>
        }
        groupBy: {
          args: Prisma.InsuranceProviderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsuranceProviderGroupByOutputType>[]
        }
        count: {
          args: Prisma.InsuranceProviderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsuranceProviderCountAggregateOutputType> | number
        }
      }
    }
    ParentCompany: {
      payload: Prisma.$ParentCompanyPayload<ExtArgs>
      fields: Prisma.ParentCompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ParentCompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ParentCompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>
        }
        findFirst: {
          args: Prisma.ParentCompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ParentCompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>
        }
        findMany: {
          args: Prisma.ParentCompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>[]
        }
        create: {
          args: Prisma.ParentCompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>
        }
        createMany: {
          args: Prisma.ParentCompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ParentCompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>[]
        }
        delete: {
          args: Prisma.ParentCompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>
        }
        update: {
          args: Prisma.ParentCompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>
        }
        deleteMany: {
          args: Prisma.ParentCompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ParentCompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ParentCompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>[]
        }
        upsert: {
          args: Prisma.ParentCompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentCompanyPayload>
        }
        aggregate: {
          args: Prisma.ParentCompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateParentCompany>
        }
        groupBy: {
          args: Prisma.ParentCompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ParentCompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ParentCompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ParentCompanyCountAggregateOutputType> | number
        }
      }
    }
    YoutubeChannel: {
      payload: Prisma.$YoutubeChannelPayload<ExtArgs>
      fields: Prisma.YoutubeChannelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.YoutubeChannelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.YoutubeChannelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>
        }
        findFirst: {
          args: Prisma.YoutubeChannelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.YoutubeChannelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>
        }
        findMany: {
          args: Prisma.YoutubeChannelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>[]
        }
        create: {
          args: Prisma.YoutubeChannelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>
        }
        createMany: {
          args: Prisma.YoutubeChannelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.YoutubeChannelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>[]
        }
        delete: {
          args: Prisma.YoutubeChannelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>
        }
        update: {
          args: Prisma.YoutubeChannelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>
        }
        deleteMany: {
          args: Prisma.YoutubeChannelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.YoutubeChannelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.YoutubeChannelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>[]
        }
        upsert: {
          args: Prisma.YoutubeChannelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeChannelPayload>
        }
        aggregate: {
          args: Prisma.YoutubeChannelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateYoutubeChannel>
        }
        groupBy: {
          args: Prisma.YoutubeChannelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YoutubeChannelGroupByOutputType>[]
        }
        count: {
          args: Prisma.YoutubeChannelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YoutubeChannelCountAggregateOutputType> | number
        }
      }
    }
    YoutubeVideo: {
      payload: Prisma.$YoutubeVideoPayload<ExtArgs>
      fields: Prisma.YoutubeVideoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.YoutubeVideoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.YoutubeVideoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>
        }
        findFirst: {
          args: Prisma.YoutubeVideoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.YoutubeVideoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>
        }
        findMany: {
          args: Prisma.YoutubeVideoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>[]
        }
        create: {
          args: Prisma.YoutubeVideoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>
        }
        createMany: {
          args: Prisma.YoutubeVideoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.YoutubeVideoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>[]
        }
        delete: {
          args: Prisma.YoutubeVideoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>
        }
        update: {
          args: Prisma.YoutubeVideoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>
        }
        deleteMany: {
          args: Prisma.YoutubeVideoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.YoutubeVideoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.YoutubeVideoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>[]
        }
        upsert: {
          args: Prisma.YoutubeVideoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YoutubeVideoPayload>
        }
        aggregate: {
          args: Prisma.YoutubeVideoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateYoutubeVideo>
        }
        groupBy: {
          args: Prisma.YoutubeVideoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YoutubeVideoGroupByOutputType>[]
        }
        count: {
          args: Prisma.YoutubeVideoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YoutubeVideoCountAggregateOutputType> | number
        }
      }
    }
    SocialMediaProfile: {
      payload: Prisma.$SocialMediaProfilePayload<ExtArgs>
      fields: Prisma.SocialMediaProfileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SocialMediaProfileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SocialMediaProfileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>
        }
        findFirst: {
          args: Prisma.SocialMediaProfileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SocialMediaProfileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>
        }
        findMany: {
          args: Prisma.SocialMediaProfileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>[]
        }
        create: {
          args: Prisma.SocialMediaProfileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>
        }
        createMany: {
          args: Prisma.SocialMediaProfileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SocialMediaProfileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>[]
        }
        delete: {
          args: Prisma.SocialMediaProfileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>
        }
        update: {
          args: Prisma.SocialMediaProfileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>
        }
        deleteMany: {
          args: Prisma.SocialMediaProfileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SocialMediaProfileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SocialMediaProfileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>[]
        }
        upsert: {
          args: Prisma.SocialMediaProfileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialMediaProfilePayload>
        }
        aggregate: {
          args: Prisma.SocialMediaProfileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSocialMediaProfile>
        }
        groupBy: {
          args: Prisma.SocialMediaProfileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SocialMediaProfileGroupByOutputType>[]
        }
        count: {
          args: Prisma.SocialMediaProfileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SocialMediaProfileCountAggregateOutputType> | number
        }
      }
    }
    RehabOrg: {
      payload: Prisma.$RehabOrgPayload<ExtArgs>
      fields: Prisma.RehabOrgFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabOrgFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabOrgFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>
        }
        findFirst: {
          args: Prisma.RehabOrgFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabOrgFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>
        }
        findMany: {
          args: Prisma.RehabOrgFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>[]
        }
        create: {
          args: Prisma.RehabOrgCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>
        }
        createMany: {
          args: Prisma.RehabOrgCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabOrgCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>[]
        }
        delete: {
          args: Prisma.RehabOrgDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>
        }
        update: {
          args: Prisma.RehabOrgUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>
        }
        deleteMany: {
          args: Prisma.RehabOrgDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabOrgUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabOrgUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>[]
        }
        upsert: {
          args: Prisma.RehabOrgUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabOrgPayload>
        }
        aggregate: {
          args: Prisma.RehabOrgAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabOrg>
        }
        groupBy: {
          args: Prisma.RehabOrgGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabOrgGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabOrgCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabOrgCountAggregateOutputType> | number
        }
      }
    }
    RehabCampus: {
      payload: Prisma.$RehabCampusPayload<ExtArgs>
      fields: Prisma.RehabCampusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>
        }
        findFirst: {
          args: Prisma.RehabCampusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>
        }
        findMany: {
          args: Prisma.RehabCampusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>[]
        }
        create: {
          args: Prisma.RehabCampusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>
        }
        createMany: {
          args: Prisma.RehabCampusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>[]
        }
        delete: {
          args: Prisma.RehabCampusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>
        }
        update: {
          args: Prisma.RehabCampusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPayload>
        }
        aggregate: {
          args: Prisma.RehabCampusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampus>
        }
        groupBy: {
          args: Prisma.RehabCampusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusCountAggregateOutputType> | number
        }
      }
    }
    RehabProgram: {
      payload: Prisma.$RehabProgramPayload<ExtArgs>
      fields: Prisma.RehabProgramFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>
        }
        findFirst: {
          args: Prisma.RehabProgramFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>
        }
        findMany: {
          args: Prisma.RehabProgramFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>[]
        }
        create: {
          args: Prisma.RehabProgramCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>
        }
        createMany: {
          args: Prisma.RehabProgramCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>[]
        }
        delete: {
          args: Prisma.RehabProgramDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>
        }
        update: {
          args: Prisma.RehabProgramUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPayload>
        }
        aggregate: {
          args: Prisma.RehabProgramAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgram>
        }
        groupBy: {
          args: Prisma.RehabProgramGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramCountAggregateOutputType> | number
        }
      }
    }
    LevelOfCare: {
      payload: Prisma.$LevelOfCarePayload<ExtArgs>
      fields: Prisma.LevelOfCareFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LevelOfCareFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LevelOfCareFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>
        }
        findFirst: {
          args: Prisma.LevelOfCareFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LevelOfCareFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>
        }
        findMany: {
          args: Prisma.LevelOfCareFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>[]
        }
        create: {
          args: Prisma.LevelOfCareCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>
        }
        createMany: {
          args: Prisma.LevelOfCareCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LevelOfCareCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>[]
        }
        delete: {
          args: Prisma.LevelOfCareDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>
        }
        update: {
          args: Prisma.LevelOfCareUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>
        }
        deleteMany: {
          args: Prisma.LevelOfCareDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LevelOfCareUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LevelOfCareUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>[]
        }
        upsert: {
          args: Prisma.LevelOfCareUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LevelOfCarePayload>
        }
        aggregate: {
          args: Prisma.LevelOfCareAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLevelOfCare>
        }
        groupBy: {
          args: Prisma.LevelOfCareGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LevelOfCareGroupByOutputType>[]
        }
        count: {
          args: Prisma.LevelOfCareCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LevelOfCareCountAggregateOutputType> | number
        }
      }
    }
    DetoxService: {
      payload: Prisma.$DetoxServicePayload<ExtArgs>
      fields: Prisma.DetoxServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DetoxServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DetoxServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>
        }
        findFirst: {
          args: Prisma.DetoxServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DetoxServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>
        }
        findMany: {
          args: Prisma.DetoxServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>[]
        }
        create: {
          args: Prisma.DetoxServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>
        }
        createMany: {
          args: Prisma.DetoxServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DetoxServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>[]
        }
        delete: {
          args: Prisma.DetoxServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>
        }
        update: {
          args: Prisma.DetoxServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>
        }
        deleteMany: {
          args: Prisma.DetoxServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DetoxServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DetoxServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>[]
        }
        upsert: {
          args: Prisma.DetoxServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DetoxServicePayload>
        }
        aggregate: {
          args: Prisma.DetoxServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDetoxService>
        }
        groupBy: {
          args: Prisma.DetoxServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DetoxServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.DetoxServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DetoxServiceCountAggregateOutputType> | number
        }
      }
    }
    MATType: {
      payload: Prisma.$MATTypePayload<ExtArgs>
      fields: Prisma.MATTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MATTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MATTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>
        }
        findFirst: {
          args: Prisma.MATTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MATTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>
        }
        findMany: {
          args: Prisma.MATTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>[]
        }
        create: {
          args: Prisma.MATTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>
        }
        createMany: {
          args: Prisma.MATTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MATTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>[]
        }
        delete: {
          args: Prisma.MATTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>
        }
        update: {
          args: Prisma.MATTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>
        }
        deleteMany: {
          args: Prisma.MATTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MATTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MATTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>[]
        }
        upsert: {
          args: Prisma.MATTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MATTypePayload>
        }
        aggregate: {
          args: Prisma.MATTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMATType>
        }
        groupBy: {
          args: Prisma.MATTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MATTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.MATTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MATTypeCountAggregateOutputType> | number
        }
      }
    }
    Service: {
      payload: Prisma.$ServicePayload<ExtArgs>
      fields: Prisma.ServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findFirst: {
          args: Prisma.ServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findMany: {
          args: Prisma.ServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        create: {
          args: Prisma.ServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        createMany: {
          args: Prisma.ServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        delete: {
          args: Prisma.ServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        update: {
          args: Prisma.ServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        deleteMany: {
          args: Prisma.ServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        upsert: {
          args: Prisma.ServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        aggregate: {
          args: Prisma.ServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService>
        }
        groupBy: {
          args: Prisma.ServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType> | number
        }
      }
    }
    Population: {
      payload: Prisma.$PopulationPayload<ExtArgs>
      fields: Prisma.PopulationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PopulationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PopulationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>
        }
        findFirst: {
          args: Prisma.PopulationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PopulationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>
        }
        findMany: {
          args: Prisma.PopulationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>[]
        }
        create: {
          args: Prisma.PopulationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>
        }
        createMany: {
          args: Prisma.PopulationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PopulationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>[]
        }
        delete: {
          args: Prisma.PopulationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>
        }
        update: {
          args: Prisma.PopulationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>
        }
        deleteMany: {
          args: Prisma.PopulationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PopulationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PopulationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>[]
        }
        upsert: {
          args: Prisma.PopulationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PopulationPayload>
        }
        aggregate: {
          args: Prisma.PopulationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePopulation>
        }
        groupBy: {
          args: Prisma.PopulationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PopulationGroupByOutputType>[]
        }
        count: {
          args: Prisma.PopulationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PopulationCountAggregateOutputType> | number
        }
      }
    }
    Accreditation: {
      payload: Prisma.$AccreditationPayload<ExtArgs>
      fields: Prisma.AccreditationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccreditationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccreditationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>
        }
        findFirst: {
          args: Prisma.AccreditationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccreditationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>
        }
        findMany: {
          args: Prisma.AccreditationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>[]
        }
        create: {
          args: Prisma.AccreditationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>
        }
        createMany: {
          args: Prisma.AccreditationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccreditationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>[]
        }
        delete: {
          args: Prisma.AccreditationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>
        }
        update: {
          args: Prisma.AccreditationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>
        }
        deleteMany: {
          args: Prisma.AccreditationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccreditationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccreditationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>[]
        }
        upsert: {
          args: Prisma.AccreditationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccreditationPayload>
        }
        aggregate: {
          args: Prisma.AccreditationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccreditation>
        }
        groupBy: {
          args: Prisma.AccreditationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccreditationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccreditationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccreditationCountAggregateOutputType> | number
        }
      }
    }
    Language: {
      payload: Prisma.$LanguagePayload<ExtArgs>
      fields: Prisma.LanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        findFirst: {
          args: Prisma.LanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        findMany: {
          args: Prisma.LanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>[]
        }
        create: {
          args: Prisma.LanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        createMany: {
          args: Prisma.LanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>[]
        }
        delete: {
          args: Prisma.LanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        update: {
          args: Prisma.LanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        deleteMany: {
          args: Prisma.LanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>[]
        }
        upsert: {
          args: Prisma.LanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LanguagePayload>
        }
        aggregate: {
          args: Prisma.LanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLanguage>
        }
        groupBy: {
          args: Prisma.LanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.LanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LanguageCountAggregateOutputType> | number
        }
      }
    }
    Amenity: {
      payload: Prisma.$AmenityPayload<ExtArgs>
      fields: Prisma.AmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        findFirst: {
          args: Prisma.AmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        findMany: {
          args: Prisma.AmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        create: {
          args: Prisma.AmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        createMany: {
          args: Prisma.AmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        delete: {
          args: Prisma.AmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        update: {
          args: Prisma.AmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        deleteMany: {
          args: Prisma.AmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        upsert: {
          args: Prisma.AmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        aggregate: {
          args: Prisma.AmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAmenity>
        }
        groupBy: {
          args: Prisma.AmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.AmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AmenityCountAggregateOutputType> | number
        }
      }
    }
    Environment: {
      payload: Prisma.$EnvironmentPayload<ExtArgs>
      fields: Prisma.EnvironmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EnvironmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EnvironmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>
        }
        findFirst: {
          args: Prisma.EnvironmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EnvironmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>
        }
        findMany: {
          args: Prisma.EnvironmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
        }
        create: {
          args: Prisma.EnvironmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>
        }
        createMany: {
          args: Prisma.EnvironmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EnvironmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
        }
        delete: {
          args: Prisma.EnvironmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>
        }
        update: {
          args: Prisma.EnvironmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>
        }
        deleteMany: {
          args: Prisma.EnvironmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EnvironmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EnvironmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
        }
        upsert: {
          args: Prisma.EnvironmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnvironmentPayload>
        }
        aggregate: {
          args: Prisma.EnvironmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEnvironment>
        }
        groupBy: {
          args: Prisma.EnvironmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EnvironmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.EnvironmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EnvironmentCountAggregateOutputType> | number
        }
      }
    }
    SettingStyle: {
      payload: Prisma.$SettingStylePayload<ExtArgs>
      fields: Prisma.SettingStyleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SettingStyleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SettingStyleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>
        }
        findFirst: {
          args: Prisma.SettingStyleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SettingStyleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>
        }
        findMany: {
          args: Prisma.SettingStyleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>[]
        }
        create: {
          args: Prisma.SettingStyleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>
        }
        createMany: {
          args: Prisma.SettingStyleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SettingStyleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>[]
        }
        delete: {
          args: Prisma.SettingStyleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>
        }
        update: {
          args: Prisma.SettingStyleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>
        }
        deleteMany: {
          args: Prisma.SettingStyleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SettingStyleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SettingStyleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>[]
        }
        upsert: {
          args: Prisma.SettingStyleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingStylePayload>
        }
        aggregate: {
          args: Prisma.SettingStyleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSettingStyle>
        }
        groupBy: {
          args: Prisma.SettingStyleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SettingStyleGroupByOutputType>[]
        }
        count: {
          args: Prisma.SettingStyleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SettingStyleCountAggregateOutputType> | number
        }
      }
    }
    LuxuryTier: {
      payload: Prisma.$LuxuryTierPayload<ExtArgs>
      fields: Prisma.LuxuryTierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LuxuryTierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LuxuryTierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>
        }
        findFirst: {
          args: Prisma.LuxuryTierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LuxuryTierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>
        }
        findMany: {
          args: Prisma.LuxuryTierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>[]
        }
        create: {
          args: Prisma.LuxuryTierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>
        }
        createMany: {
          args: Prisma.LuxuryTierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LuxuryTierCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>[]
        }
        delete: {
          args: Prisma.LuxuryTierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>
        }
        update: {
          args: Prisma.LuxuryTierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>
        }
        deleteMany: {
          args: Prisma.LuxuryTierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LuxuryTierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LuxuryTierUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>[]
        }
        upsert: {
          args: Prisma.LuxuryTierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LuxuryTierPayload>
        }
        aggregate: {
          args: Prisma.LuxuryTierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLuxuryTier>
        }
        groupBy: {
          args: Prisma.LuxuryTierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LuxuryTierGroupByOutputType>[]
        }
        count: {
          args: Prisma.LuxuryTierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LuxuryTierCountAggregateOutputType> | number
        }
      }
    }
    ProgramFeature: {
      payload: Prisma.$ProgramFeaturePayload<ExtArgs>
      fields: Prisma.ProgramFeatureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramFeatureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramFeatureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>
        }
        findFirst: {
          args: Prisma.ProgramFeatureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramFeatureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>
        }
        findMany: {
          args: Prisma.ProgramFeatureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>[]
        }
        create: {
          args: Prisma.ProgramFeatureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>
        }
        createMany: {
          args: Prisma.ProgramFeatureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramFeatureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>[]
        }
        delete: {
          args: Prisma.ProgramFeatureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>
        }
        update: {
          args: Prisma.ProgramFeatureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>
        }
        deleteMany: {
          args: Prisma.ProgramFeatureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramFeatureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramFeatureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>[]
        }
        upsert: {
          args: Prisma.ProgramFeatureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramFeaturePayload>
        }
        aggregate: {
          args: Prisma.ProgramFeatureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramFeature>
        }
        groupBy: {
          args: Prisma.ProgramFeatureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramFeatureGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramFeatureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramFeatureCountAggregateOutputType> | number
        }
      }
    }
    PaymentOption: {
      payload: Prisma.$PaymentOptionPayload<ExtArgs>
      fields: Prisma.PaymentOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>
        }
        findFirst: {
          args: Prisma.PaymentOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>
        }
        findMany: {
          args: Prisma.PaymentOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>[]
        }
        create: {
          args: Prisma.PaymentOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>
        }
        createMany: {
          args: Prisma.PaymentOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>[]
        }
        delete: {
          args: Prisma.PaymentOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>
        }
        update: {
          args: Prisma.PaymentOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>
        }
        deleteMany: {
          args: Prisma.PaymentOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>[]
        }
        upsert: {
          args: Prisma.PaymentOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentOptionPayload>
        }
        aggregate: {
          args: Prisma.PaymentOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentOption>
        }
        groupBy: {
          args: Prisma.PaymentOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentOptionCountAggregateOutputType> | number
        }
      }
    }
    InsurancePayer: {
      payload: Prisma.$InsurancePayerPayload<ExtArgs>
      fields: Prisma.InsurancePayerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InsurancePayerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InsurancePayerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>
        }
        findFirst: {
          args: Prisma.InsurancePayerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InsurancePayerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>
        }
        findMany: {
          args: Prisma.InsurancePayerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>[]
        }
        create: {
          args: Prisma.InsurancePayerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>
        }
        createMany: {
          args: Prisma.InsurancePayerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InsurancePayerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>[]
        }
        delete: {
          args: Prisma.InsurancePayerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>
        }
        update: {
          args: Prisma.InsurancePayerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>
        }
        deleteMany: {
          args: Prisma.InsurancePayerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InsurancePayerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InsurancePayerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>[]
        }
        upsert: {
          args: Prisma.InsurancePayerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsurancePayerPayload>
        }
        aggregate: {
          args: Prisma.InsurancePayerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInsurancePayer>
        }
        groupBy: {
          args: Prisma.InsurancePayerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsurancePayerGroupByOutputType>[]
        }
        count: {
          args: Prisma.InsurancePayerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsurancePayerCountAggregateOutputType> | number
        }
      }
    }
    Substance: {
      payload: Prisma.$SubstancePayload<ExtArgs>
      fields: Prisma.SubstanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubstanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubstanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>
        }
        findFirst: {
          args: Prisma.SubstanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubstanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>
        }
        findMany: {
          args: Prisma.SubstanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>[]
        }
        create: {
          args: Prisma.SubstanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>
        }
        createMany: {
          args: Prisma.SubstanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubstanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>[]
        }
        delete: {
          args: Prisma.SubstanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>
        }
        update: {
          args: Prisma.SubstanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>
        }
        deleteMany: {
          args: Prisma.SubstanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubstanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubstanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>[]
        }
        upsert: {
          args: Prisma.SubstanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubstancePayload>
        }
        aggregate: {
          args: Prisma.SubstanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubstance>
        }
        groupBy: {
          args: Prisma.SubstanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubstanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubstanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubstanceCountAggregateOutputType> | number
        }
      }
    }
    RehabLevelOfCare: {
      payload: Prisma.$RehabLevelOfCarePayload<ExtArgs>
      fields: Prisma.RehabLevelOfCareFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabLevelOfCareFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabLevelOfCareFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>
        }
        findFirst: {
          args: Prisma.RehabLevelOfCareFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabLevelOfCareFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>
        }
        findMany: {
          args: Prisma.RehabLevelOfCareFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>[]
        }
        create: {
          args: Prisma.RehabLevelOfCareCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>
        }
        createMany: {
          args: Prisma.RehabLevelOfCareCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabLevelOfCareCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>[]
        }
        delete: {
          args: Prisma.RehabLevelOfCareDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>
        }
        update: {
          args: Prisma.RehabLevelOfCareUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>
        }
        deleteMany: {
          args: Prisma.RehabLevelOfCareDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabLevelOfCareUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabLevelOfCareUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>[]
        }
        upsert: {
          args: Prisma.RehabLevelOfCareUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLevelOfCarePayload>
        }
        aggregate: {
          args: Prisma.RehabLevelOfCareAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabLevelOfCare>
        }
        groupBy: {
          args: Prisma.RehabLevelOfCareGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabLevelOfCareGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabLevelOfCareCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabLevelOfCareCountAggregateOutputType> | number
        }
      }
    }
    RehabDetoxService: {
      payload: Prisma.$RehabDetoxServicePayload<ExtArgs>
      fields: Prisma.RehabDetoxServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabDetoxServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabDetoxServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>
        }
        findFirst: {
          args: Prisma.RehabDetoxServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabDetoxServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>
        }
        findMany: {
          args: Prisma.RehabDetoxServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>[]
        }
        create: {
          args: Prisma.RehabDetoxServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>
        }
        createMany: {
          args: Prisma.RehabDetoxServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabDetoxServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>[]
        }
        delete: {
          args: Prisma.RehabDetoxServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>
        }
        update: {
          args: Prisma.RehabDetoxServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>
        }
        deleteMany: {
          args: Prisma.RehabDetoxServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabDetoxServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabDetoxServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>[]
        }
        upsert: {
          args: Prisma.RehabDetoxServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabDetoxServicePayload>
        }
        aggregate: {
          args: Prisma.RehabDetoxServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabDetoxService>
        }
        groupBy: {
          args: Prisma.RehabDetoxServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabDetoxServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabDetoxServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabDetoxServiceCountAggregateOutputType> | number
        }
      }
    }
    RehabService: {
      payload: Prisma.$RehabServicePayload<ExtArgs>
      fields: Prisma.RehabServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>
        }
        findFirst: {
          args: Prisma.RehabServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>
        }
        findMany: {
          args: Prisma.RehabServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>[]
        }
        create: {
          args: Prisma.RehabServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>
        }
        createMany: {
          args: Prisma.RehabServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>[]
        }
        delete: {
          args: Prisma.RehabServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>
        }
        update: {
          args: Prisma.RehabServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>
        }
        deleteMany: {
          args: Prisma.RehabServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>[]
        }
        upsert: {
          args: Prisma.RehabServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabServicePayload>
        }
        aggregate: {
          args: Prisma.RehabServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabService>
        }
        groupBy: {
          args: Prisma.RehabServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabServiceCountAggregateOutputType> | number
        }
      }
    }
    RehabPopulation: {
      payload: Prisma.$RehabPopulationPayload<ExtArgs>
      fields: Prisma.RehabPopulationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabPopulationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabPopulationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>
        }
        findFirst: {
          args: Prisma.RehabPopulationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabPopulationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>
        }
        findMany: {
          args: Prisma.RehabPopulationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>[]
        }
        create: {
          args: Prisma.RehabPopulationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>
        }
        createMany: {
          args: Prisma.RehabPopulationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabPopulationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>[]
        }
        delete: {
          args: Prisma.RehabPopulationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>
        }
        update: {
          args: Prisma.RehabPopulationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>
        }
        deleteMany: {
          args: Prisma.RehabPopulationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabPopulationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabPopulationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>[]
        }
        upsert: {
          args: Prisma.RehabPopulationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPopulationPayload>
        }
        aggregate: {
          args: Prisma.RehabPopulationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabPopulation>
        }
        groupBy: {
          args: Prisma.RehabPopulationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabPopulationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabPopulationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabPopulationCountAggregateOutputType> | number
        }
      }
    }
    RehabAccreditation: {
      payload: Prisma.$RehabAccreditationPayload<ExtArgs>
      fields: Prisma.RehabAccreditationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabAccreditationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabAccreditationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>
        }
        findFirst: {
          args: Prisma.RehabAccreditationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabAccreditationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>
        }
        findMany: {
          args: Prisma.RehabAccreditationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>[]
        }
        create: {
          args: Prisma.RehabAccreditationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>
        }
        createMany: {
          args: Prisma.RehabAccreditationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabAccreditationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>[]
        }
        delete: {
          args: Prisma.RehabAccreditationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>
        }
        update: {
          args: Prisma.RehabAccreditationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>
        }
        deleteMany: {
          args: Prisma.RehabAccreditationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabAccreditationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabAccreditationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>[]
        }
        upsert: {
          args: Prisma.RehabAccreditationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAccreditationPayload>
        }
        aggregate: {
          args: Prisma.RehabAccreditationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabAccreditation>
        }
        groupBy: {
          args: Prisma.RehabAccreditationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabAccreditationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabAccreditationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabAccreditationCountAggregateOutputType> | number
        }
      }
    }
    RehabLanguage: {
      payload: Prisma.$RehabLanguagePayload<ExtArgs>
      fields: Prisma.RehabLanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabLanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabLanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>
        }
        findFirst: {
          args: Prisma.RehabLanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabLanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>
        }
        findMany: {
          args: Prisma.RehabLanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>[]
        }
        create: {
          args: Prisma.RehabLanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>
        }
        createMany: {
          args: Prisma.RehabLanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabLanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>[]
        }
        delete: {
          args: Prisma.RehabLanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>
        }
        update: {
          args: Prisma.RehabLanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>
        }
        deleteMany: {
          args: Prisma.RehabLanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabLanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabLanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>[]
        }
        upsert: {
          args: Prisma.RehabLanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLanguagePayload>
        }
        aggregate: {
          args: Prisma.RehabLanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabLanguage>
        }
        groupBy: {
          args: Prisma.RehabLanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabLanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabLanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabLanguageCountAggregateOutputType> | number
        }
      }
    }
    RehabAmenity: {
      payload: Prisma.$RehabAmenityPayload<ExtArgs>
      fields: Prisma.RehabAmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabAmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabAmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>
        }
        findFirst: {
          args: Prisma.RehabAmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabAmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>
        }
        findMany: {
          args: Prisma.RehabAmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>[]
        }
        create: {
          args: Prisma.RehabAmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>
        }
        createMany: {
          args: Prisma.RehabAmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabAmenityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>[]
        }
        delete: {
          args: Prisma.RehabAmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>
        }
        update: {
          args: Prisma.RehabAmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>
        }
        deleteMany: {
          args: Prisma.RehabAmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabAmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabAmenityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>[]
        }
        upsert: {
          args: Prisma.RehabAmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabAmenityPayload>
        }
        aggregate: {
          args: Prisma.RehabAmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabAmenity>
        }
        groupBy: {
          args: Prisma.RehabAmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabAmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabAmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabAmenityCountAggregateOutputType> | number
        }
      }
    }
    RehabEnvironment: {
      payload: Prisma.$RehabEnvironmentPayload<ExtArgs>
      fields: Prisma.RehabEnvironmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabEnvironmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabEnvironmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>
        }
        findFirst: {
          args: Prisma.RehabEnvironmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabEnvironmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>
        }
        findMany: {
          args: Prisma.RehabEnvironmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>[]
        }
        create: {
          args: Prisma.RehabEnvironmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>
        }
        createMany: {
          args: Prisma.RehabEnvironmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabEnvironmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>[]
        }
        delete: {
          args: Prisma.RehabEnvironmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>
        }
        update: {
          args: Prisma.RehabEnvironmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>
        }
        deleteMany: {
          args: Prisma.RehabEnvironmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabEnvironmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabEnvironmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>[]
        }
        upsert: {
          args: Prisma.RehabEnvironmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabEnvironmentPayload>
        }
        aggregate: {
          args: Prisma.RehabEnvironmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabEnvironment>
        }
        groupBy: {
          args: Prisma.RehabEnvironmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabEnvironmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabEnvironmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabEnvironmentCountAggregateOutputType> | number
        }
      }
    }
    RehabSettingStyle: {
      payload: Prisma.$RehabSettingStylePayload<ExtArgs>
      fields: Prisma.RehabSettingStyleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabSettingStyleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabSettingStyleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>
        }
        findFirst: {
          args: Prisma.RehabSettingStyleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabSettingStyleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>
        }
        findMany: {
          args: Prisma.RehabSettingStyleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>[]
        }
        create: {
          args: Prisma.RehabSettingStyleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>
        }
        createMany: {
          args: Prisma.RehabSettingStyleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabSettingStyleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>[]
        }
        delete: {
          args: Prisma.RehabSettingStyleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>
        }
        update: {
          args: Prisma.RehabSettingStyleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>
        }
        deleteMany: {
          args: Prisma.RehabSettingStyleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabSettingStyleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabSettingStyleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>[]
        }
        upsert: {
          args: Prisma.RehabSettingStyleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabSettingStylePayload>
        }
        aggregate: {
          args: Prisma.RehabSettingStyleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabSettingStyle>
        }
        groupBy: {
          args: Prisma.RehabSettingStyleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabSettingStyleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabSettingStyleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabSettingStyleCountAggregateOutputType> | number
        }
      }
    }
    RehabLuxuryTier: {
      payload: Prisma.$RehabLuxuryTierPayload<ExtArgs>
      fields: Prisma.RehabLuxuryTierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabLuxuryTierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabLuxuryTierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>
        }
        findFirst: {
          args: Prisma.RehabLuxuryTierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabLuxuryTierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>
        }
        findMany: {
          args: Prisma.RehabLuxuryTierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>[]
        }
        create: {
          args: Prisma.RehabLuxuryTierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>
        }
        createMany: {
          args: Prisma.RehabLuxuryTierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabLuxuryTierCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>[]
        }
        delete: {
          args: Prisma.RehabLuxuryTierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>
        }
        update: {
          args: Prisma.RehabLuxuryTierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>
        }
        deleteMany: {
          args: Prisma.RehabLuxuryTierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabLuxuryTierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabLuxuryTierUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>[]
        }
        upsert: {
          args: Prisma.RehabLuxuryTierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabLuxuryTierPayload>
        }
        aggregate: {
          args: Prisma.RehabLuxuryTierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabLuxuryTier>
        }
        groupBy: {
          args: Prisma.RehabLuxuryTierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabLuxuryTierGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabLuxuryTierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabLuxuryTierCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramFeatureGlobal: {
      payload: Prisma.$RehabProgramFeatureGlobalPayload<ExtArgs>
      fields: Prisma.RehabProgramFeatureGlobalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramFeatureGlobalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramFeatureGlobalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>
        }
        findFirst: {
          args: Prisma.RehabProgramFeatureGlobalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramFeatureGlobalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>
        }
        findMany: {
          args: Prisma.RehabProgramFeatureGlobalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>[]
        }
        create: {
          args: Prisma.RehabProgramFeatureGlobalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>
        }
        createMany: {
          args: Prisma.RehabProgramFeatureGlobalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramFeatureGlobalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>[]
        }
        delete: {
          args: Prisma.RehabProgramFeatureGlobalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>
        }
        update: {
          args: Prisma.RehabProgramFeatureGlobalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramFeatureGlobalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramFeatureGlobalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramFeatureGlobalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramFeatureGlobalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeatureGlobalPayload>
        }
        aggregate: {
          args: Prisma.RehabProgramFeatureGlobalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramFeatureGlobal>
        }
        groupBy: {
          args: Prisma.RehabProgramFeatureGlobalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramFeatureGlobalGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramFeatureGlobalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramFeatureGlobalCountAggregateOutputType> | number
        }
      }
    }
    RehabCampusAmenity: {
      payload: Prisma.$RehabCampusAmenityPayload<ExtArgs>
      fields: Prisma.RehabCampusAmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusAmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusAmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>
        }
        findFirst: {
          args: Prisma.RehabCampusAmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusAmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>
        }
        findMany: {
          args: Prisma.RehabCampusAmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>[]
        }
        create: {
          args: Prisma.RehabCampusAmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>
        }
        createMany: {
          args: Prisma.RehabCampusAmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusAmenityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>[]
        }
        delete: {
          args: Prisma.RehabCampusAmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>
        }
        update: {
          args: Prisma.RehabCampusAmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusAmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusAmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusAmenityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusAmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusAmenityPayload>
        }
        aggregate: {
          args: Prisma.RehabCampusAmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampusAmenity>
        }
        groupBy: {
          args: Prisma.RehabCampusAmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusAmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusAmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusAmenityCountAggregateOutputType> | number
        }
      }
    }
    RehabCampusLanguage: {
      payload: Prisma.$RehabCampusLanguagePayload<ExtArgs>
      fields: Prisma.RehabCampusLanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusLanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusLanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>
        }
        findFirst: {
          args: Prisma.RehabCampusLanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusLanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>
        }
        findMany: {
          args: Prisma.RehabCampusLanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>[]
        }
        create: {
          args: Prisma.RehabCampusLanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>
        }
        createMany: {
          args: Prisma.RehabCampusLanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusLanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>[]
        }
        delete: {
          args: Prisma.RehabCampusLanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>
        }
        update: {
          args: Prisma.RehabCampusLanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusLanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusLanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusLanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusLanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLanguagePayload>
        }
        aggregate: {
          args: Prisma.RehabCampusLanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampusLanguage>
        }
        groupBy: {
          args: Prisma.RehabCampusLanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusLanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusLanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusLanguageCountAggregateOutputType> | number
        }
      }
    }
    RehabCampusPopulation: {
      payload: Prisma.$RehabCampusPopulationPayload<ExtArgs>
      fields: Prisma.RehabCampusPopulationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusPopulationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusPopulationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>
        }
        findFirst: {
          args: Prisma.RehabCampusPopulationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusPopulationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>
        }
        findMany: {
          args: Prisma.RehabCampusPopulationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>[]
        }
        create: {
          args: Prisma.RehabCampusPopulationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>
        }
        createMany: {
          args: Prisma.RehabCampusPopulationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusPopulationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>[]
        }
        delete: {
          args: Prisma.RehabCampusPopulationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>
        }
        update: {
          args: Prisma.RehabCampusPopulationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusPopulationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusPopulationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusPopulationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusPopulationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusPopulationPayload>
        }
        aggregate: {
          args: Prisma.RehabCampusPopulationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampusPopulation>
        }
        groupBy: {
          args: Prisma.RehabCampusPopulationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusPopulationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusPopulationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusPopulationCountAggregateOutputType> | number
        }
      }
    }
    RehabCampusEnvironment: {
      payload: Prisma.$RehabCampusEnvironmentPayload<ExtArgs>
      fields: Prisma.RehabCampusEnvironmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusEnvironmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusEnvironmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>
        }
        findFirst: {
          args: Prisma.RehabCampusEnvironmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusEnvironmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>
        }
        findMany: {
          args: Prisma.RehabCampusEnvironmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>[]
        }
        create: {
          args: Prisma.RehabCampusEnvironmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>
        }
        createMany: {
          args: Prisma.RehabCampusEnvironmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusEnvironmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>[]
        }
        delete: {
          args: Prisma.RehabCampusEnvironmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>
        }
        update: {
          args: Prisma.RehabCampusEnvironmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusEnvironmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusEnvironmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusEnvironmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusEnvironmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusEnvironmentPayload>
        }
        aggregate: {
          args: Prisma.RehabCampusEnvironmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampusEnvironment>
        }
        groupBy: {
          args: Prisma.RehabCampusEnvironmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusEnvironmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusEnvironmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusEnvironmentCountAggregateOutputType> | number
        }
      }
    }
    RehabCampusSettingStyle: {
      payload: Prisma.$RehabCampusSettingStylePayload<ExtArgs>
      fields: Prisma.RehabCampusSettingStyleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusSettingStyleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusSettingStyleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>
        }
        findFirst: {
          args: Prisma.RehabCampusSettingStyleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusSettingStyleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>
        }
        findMany: {
          args: Prisma.RehabCampusSettingStyleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>[]
        }
        create: {
          args: Prisma.RehabCampusSettingStyleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>
        }
        createMany: {
          args: Prisma.RehabCampusSettingStyleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusSettingStyleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>[]
        }
        delete: {
          args: Prisma.RehabCampusSettingStyleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>
        }
        update: {
          args: Prisma.RehabCampusSettingStyleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusSettingStyleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusSettingStyleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusSettingStyleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusSettingStyleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusSettingStylePayload>
        }
        aggregate: {
          args: Prisma.RehabCampusSettingStyleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampusSettingStyle>
        }
        groupBy: {
          args: Prisma.RehabCampusSettingStyleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusSettingStyleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusSettingStyleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusSettingStyleCountAggregateOutputType> | number
        }
      }
    }
    RehabCampusLuxuryTier: {
      payload: Prisma.$RehabCampusLuxuryTierPayload<ExtArgs>
      fields: Prisma.RehabCampusLuxuryTierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabCampusLuxuryTierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabCampusLuxuryTierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>
        }
        findFirst: {
          args: Prisma.RehabCampusLuxuryTierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabCampusLuxuryTierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>
        }
        findMany: {
          args: Prisma.RehabCampusLuxuryTierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>[]
        }
        create: {
          args: Prisma.RehabCampusLuxuryTierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>
        }
        createMany: {
          args: Prisma.RehabCampusLuxuryTierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabCampusLuxuryTierCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>[]
        }
        delete: {
          args: Prisma.RehabCampusLuxuryTierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>
        }
        update: {
          args: Prisma.RehabCampusLuxuryTierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>
        }
        deleteMany: {
          args: Prisma.RehabCampusLuxuryTierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabCampusLuxuryTierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabCampusLuxuryTierUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>[]
        }
        upsert: {
          args: Prisma.RehabCampusLuxuryTierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabCampusLuxuryTierPayload>
        }
        aggregate: {
          args: Prisma.RehabCampusLuxuryTierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabCampusLuxuryTier>
        }
        groupBy: {
          args: Prisma.RehabCampusLuxuryTierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusLuxuryTierGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabCampusLuxuryTierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabCampusLuxuryTierCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramDetoxService: {
      payload: Prisma.$RehabProgramDetoxServicePayload<ExtArgs>
      fields: Prisma.RehabProgramDetoxServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramDetoxServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramDetoxServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>
        }
        findFirst: {
          args: Prisma.RehabProgramDetoxServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramDetoxServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>
        }
        findMany: {
          args: Prisma.RehabProgramDetoxServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>[]
        }
        create: {
          args: Prisma.RehabProgramDetoxServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>
        }
        createMany: {
          args: Prisma.RehabProgramDetoxServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramDetoxServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>[]
        }
        delete: {
          args: Prisma.RehabProgramDetoxServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>
        }
        update: {
          args: Prisma.RehabProgramDetoxServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramDetoxServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramDetoxServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramDetoxServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramDetoxServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramDetoxServicePayload>
        }
        aggregate: {
          args: Prisma.RehabProgramDetoxServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramDetoxService>
        }
        groupBy: {
          args: Prisma.RehabProgramDetoxServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramDetoxServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramDetoxServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramDetoxServiceCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramMATType: {
      payload: Prisma.$RehabProgramMATTypePayload<ExtArgs>
      fields: Prisma.RehabProgramMATTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramMATTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramMATTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>
        }
        findFirst: {
          args: Prisma.RehabProgramMATTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramMATTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>
        }
        findMany: {
          args: Prisma.RehabProgramMATTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>[]
        }
        create: {
          args: Prisma.RehabProgramMATTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>
        }
        createMany: {
          args: Prisma.RehabProgramMATTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramMATTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>[]
        }
        delete: {
          args: Prisma.RehabProgramMATTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>
        }
        update: {
          args: Prisma.RehabProgramMATTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramMATTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramMATTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramMATTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramMATTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramMATTypePayload>
        }
        aggregate: {
          args: Prisma.RehabProgramMATTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramMATType>
        }
        groupBy: {
          args: Prisma.RehabProgramMATTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramMATTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramMATTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramMATTypeCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramService: {
      payload: Prisma.$RehabProgramServicePayload<ExtArgs>
      fields: Prisma.RehabProgramServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>
        }
        findFirst: {
          args: Prisma.RehabProgramServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>
        }
        findMany: {
          args: Prisma.RehabProgramServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>[]
        }
        create: {
          args: Prisma.RehabProgramServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>
        }
        createMany: {
          args: Prisma.RehabProgramServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>[]
        }
        delete: {
          args: Prisma.RehabProgramServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>
        }
        update: {
          args: Prisma.RehabProgramServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramServicePayload>
        }
        aggregate: {
          args: Prisma.RehabProgramServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramService>
        }
        groupBy: {
          args: Prisma.RehabProgramServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramServiceCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramPopulation: {
      payload: Prisma.$RehabProgramPopulationPayload<ExtArgs>
      fields: Prisma.RehabProgramPopulationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramPopulationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramPopulationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>
        }
        findFirst: {
          args: Prisma.RehabProgramPopulationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramPopulationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>
        }
        findMany: {
          args: Prisma.RehabProgramPopulationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>[]
        }
        create: {
          args: Prisma.RehabProgramPopulationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>
        }
        createMany: {
          args: Prisma.RehabProgramPopulationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramPopulationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>[]
        }
        delete: {
          args: Prisma.RehabProgramPopulationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>
        }
        update: {
          args: Prisma.RehabProgramPopulationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramPopulationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramPopulationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramPopulationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramPopulationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramPopulationPayload>
        }
        aggregate: {
          args: Prisma.RehabProgramPopulationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramPopulation>
        }
        groupBy: {
          args: Prisma.RehabProgramPopulationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramPopulationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramPopulationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramPopulationCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramLanguage: {
      payload: Prisma.$RehabProgramLanguagePayload<ExtArgs>
      fields: Prisma.RehabProgramLanguageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramLanguageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramLanguageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>
        }
        findFirst: {
          args: Prisma.RehabProgramLanguageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramLanguageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>
        }
        findMany: {
          args: Prisma.RehabProgramLanguageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>[]
        }
        create: {
          args: Prisma.RehabProgramLanguageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>
        }
        createMany: {
          args: Prisma.RehabProgramLanguageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramLanguageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>[]
        }
        delete: {
          args: Prisma.RehabProgramLanguageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>
        }
        update: {
          args: Prisma.RehabProgramLanguageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramLanguageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramLanguageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramLanguageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramLanguageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramLanguagePayload>
        }
        aggregate: {
          args: Prisma.RehabProgramLanguageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramLanguage>
        }
        groupBy: {
          args: Prisma.RehabProgramLanguageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramLanguageGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramLanguageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramLanguageCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramAmenity: {
      payload: Prisma.$RehabProgramAmenityPayload<ExtArgs>
      fields: Prisma.RehabProgramAmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramAmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramAmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>
        }
        findFirst: {
          args: Prisma.RehabProgramAmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramAmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>
        }
        findMany: {
          args: Prisma.RehabProgramAmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>[]
        }
        create: {
          args: Prisma.RehabProgramAmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>
        }
        createMany: {
          args: Prisma.RehabProgramAmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramAmenityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>[]
        }
        delete: {
          args: Prisma.RehabProgramAmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>
        }
        update: {
          args: Prisma.RehabProgramAmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramAmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramAmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramAmenityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramAmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramAmenityPayload>
        }
        aggregate: {
          args: Prisma.RehabProgramAmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramAmenity>
        }
        groupBy: {
          args: Prisma.RehabProgramAmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramAmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramAmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramAmenityCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramFeature: {
      payload: Prisma.$RehabProgramFeaturePayload<ExtArgs>
      fields: Prisma.RehabProgramFeatureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramFeatureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramFeatureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>
        }
        findFirst: {
          args: Prisma.RehabProgramFeatureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramFeatureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>
        }
        findMany: {
          args: Prisma.RehabProgramFeatureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>[]
        }
        create: {
          args: Prisma.RehabProgramFeatureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>
        }
        createMany: {
          args: Prisma.RehabProgramFeatureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramFeatureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>[]
        }
        delete: {
          args: Prisma.RehabProgramFeatureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>
        }
        update: {
          args: Prisma.RehabProgramFeatureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramFeatureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramFeatureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramFeatureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramFeatureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramFeaturePayload>
        }
        aggregate: {
          args: Prisma.RehabProgramFeatureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramFeature>
        }
        groupBy: {
          args: Prisma.RehabProgramFeatureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramFeatureGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramFeatureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramFeatureCountAggregateOutputType> | number
        }
      }
    }
    RehabProgramSubstance: {
      payload: Prisma.$RehabProgramSubstancePayload<ExtArgs>
      fields: Prisma.RehabProgramSubstanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabProgramSubstanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabProgramSubstanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>
        }
        findFirst: {
          args: Prisma.RehabProgramSubstanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabProgramSubstanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>
        }
        findMany: {
          args: Prisma.RehabProgramSubstanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>[]
        }
        create: {
          args: Prisma.RehabProgramSubstanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>
        }
        createMany: {
          args: Prisma.RehabProgramSubstanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabProgramSubstanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>[]
        }
        delete: {
          args: Prisma.RehabProgramSubstanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>
        }
        update: {
          args: Prisma.RehabProgramSubstanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>
        }
        deleteMany: {
          args: Prisma.RehabProgramSubstanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabProgramSubstanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabProgramSubstanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>[]
        }
        upsert: {
          args: Prisma.RehabProgramSubstanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabProgramSubstancePayload>
        }
        aggregate: {
          args: Prisma.RehabProgramSubstanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabProgramSubstance>
        }
        groupBy: {
          args: Prisma.RehabProgramSubstanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramSubstanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabProgramSubstanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabProgramSubstanceCountAggregateOutputType> | number
        }
      }
    }
    RehabInsurancePayer: {
      payload: Prisma.$RehabInsurancePayerPayload<ExtArgs>
      fields: Prisma.RehabInsurancePayerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabInsurancePayerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabInsurancePayerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>
        }
        findFirst: {
          args: Prisma.RehabInsurancePayerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabInsurancePayerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>
        }
        findMany: {
          args: Prisma.RehabInsurancePayerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>[]
        }
        create: {
          args: Prisma.RehabInsurancePayerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>
        }
        createMany: {
          args: Prisma.RehabInsurancePayerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabInsurancePayerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>[]
        }
        delete: {
          args: Prisma.RehabInsurancePayerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>
        }
        update: {
          args: Prisma.RehabInsurancePayerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>
        }
        deleteMany: {
          args: Prisma.RehabInsurancePayerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabInsurancePayerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabInsurancePayerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>[]
        }
        upsert: {
          args: Prisma.RehabInsurancePayerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabInsurancePayerPayload>
        }
        aggregate: {
          args: Prisma.RehabInsurancePayerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabInsurancePayer>
        }
        groupBy: {
          args: Prisma.RehabInsurancePayerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabInsurancePayerGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabInsurancePayerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabInsurancePayerCountAggregateOutputType> | number
        }
      }
    }
    RehabPaymentOption: {
      payload: Prisma.$RehabPaymentOptionPayload<ExtArgs>
      fields: Prisma.RehabPaymentOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RehabPaymentOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RehabPaymentOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>
        }
        findFirst: {
          args: Prisma.RehabPaymentOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RehabPaymentOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>
        }
        findMany: {
          args: Prisma.RehabPaymentOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>[]
        }
        create: {
          args: Prisma.RehabPaymentOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>
        }
        createMany: {
          args: Prisma.RehabPaymentOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RehabPaymentOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>[]
        }
        delete: {
          args: Prisma.RehabPaymentOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>
        }
        update: {
          args: Prisma.RehabPaymentOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>
        }
        deleteMany: {
          args: Prisma.RehabPaymentOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RehabPaymentOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RehabPaymentOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>[]
        }
        upsert: {
          args: Prisma.RehabPaymentOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RehabPaymentOptionPayload>
        }
        aggregate: {
          args: Prisma.RehabPaymentOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRehabPaymentOption>
        }
        groupBy: {
          args: Prisma.RehabPaymentOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabPaymentOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RehabPaymentOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RehabPaymentOptionCountAggregateOutputType> | number
        }
      }
    }
    OrgReview: {
      payload: Prisma.$OrgReviewPayload<ExtArgs>
      fields: Prisma.OrgReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrgReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrgReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>
        }
        findFirst: {
          args: Prisma.OrgReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrgReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>
        }
        findMany: {
          args: Prisma.OrgReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>[]
        }
        create: {
          args: Prisma.OrgReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>
        }
        createMany: {
          args: Prisma.OrgReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrgReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>[]
        }
        delete: {
          args: Prisma.OrgReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>
        }
        update: {
          args: Prisma.OrgReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>
        }
        deleteMany: {
          args: Prisma.OrgReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrgReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrgReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>[]
        }
        upsert: {
          args: Prisma.OrgReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgReviewPayload>
        }
        aggregate: {
          args: Prisma.OrgReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrgReview>
        }
        groupBy: {
          args: Prisma.OrgReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrgReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrgReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrgReviewCountAggregateOutputType> | number
        }
      }
    }
    OrgTestimonial: {
      payload: Prisma.$OrgTestimonialPayload<ExtArgs>
      fields: Prisma.OrgTestimonialFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrgTestimonialFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrgTestimonialFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>
        }
        findFirst: {
          args: Prisma.OrgTestimonialFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrgTestimonialFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>
        }
        findMany: {
          args: Prisma.OrgTestimonialFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>[]
        }
        create: {
          args: Prisma.OrgTestimonialCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>
        }
        createMany: {
          args: Prisma.OrgTestimonialCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrgTestimonialCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>[]
        }
        delete: {
          args: Prisma.OrgTestimonialDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>
        }
        update: {
          args: Prisma.OrgTestimonialUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>
        }
        deleteMany: {
          args: Prisma.OrgTestimonialDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrgTestimonialUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrgTestimonialUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>[]
        }
        upsert: {
          args: Prisma.OrgTestimonialUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgTestimonialPayload>
        }
        aggregate: {
          args: Prisma.OrgTestimonialAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrgTestimonial>
        }
        groupBy: {
          args: Prisma.OrgTestimonialGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrgTestimonialGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrgTestimonialCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrgTestimonialCountAggregateOutputType> | number
        }
      }
    }
    OrgStory: {
      payload: Prisma.$OrgStoryPayload<ExtArgs>
      fields: Prisma.OrgStoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrgStoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrgStoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>
        }
        findFirst: {
          args: Prisma.OrgStoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrgStoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>
        }
        findMany: {
          args: Prisma.OrgStoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>[]
        }
        create: {
          args: Prisma.OrgStoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>
        }
        createMany: {
          args: Prisma.OrgStoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrgStoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>[]
        }
        delete: {
          args: Prisma.OrgStoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>
        }
        update: {
          args: Prisma.OrgStoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>
        }
        deleteMany: {
          args: Prisma.OrgStoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrgStoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrgStoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>[]
        }
        upsert: {
          args: Prisma.OrgStoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgStoryPayload>
        }
        aggregate: {
          args: Prisma.OrgStoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrgStory>
        }
        groupBy: {
          args: Prisma.OrgStoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrgStoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrgStoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrgStoryCountAggregateOutputType> | number
        }
      }
    }
    CampusReview: {
      payload: Prisma.$CampusReviewPayload<ExtArgs>
      fields: Prisma.CampusReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampusReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampusReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>
        }
        findFirst: {
          args: Prisma.CampusReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampusReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>
        }
        findMany: {
          args: Prisma.CampusReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>[]
        }
        create: {
          args: Prisma.CampusReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>
        }
        createMany: {
          args: Prisma.CampusReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampusReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>[]
        }
        delete: {
          args: Prisma.CampusReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>
        }
        update: {
          args: Prisma.CampusReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>
        }
        deleteMany: {
          args: Prisma.CampusReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampusReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampusReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>[]
        }
        upsert: {
          args: Prisma.CampusReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusReviewPayload>
        }
        aggregate: {
          args: Prisma.CampusReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampusReview>
        }
        groupBy: {
          args: Prisma.CampusReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampusReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusReviewCountAggregateOutputType> | number
        }
      }
    }
    CampusTestimonial: {
      payload: Prisma.$CampusTestimonialPayload<ExtArgs>
      fields: Prisma.CampusTestimonialFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampusTestimonialFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampusTestimonialFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>
        }
        findFirst: {
          args: Prisma.CampusTestimonialFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampusTestimonialFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>
        }
        findMany: {
          args: Prisma.CampusTestimonialFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>[]
        }
        create: {
          args: Prisma.CampusTestimonialCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>
        }
        createMany: {
          args: Prisma.CampusTestimonialCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampusTestimonialCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>[]
        }
        delete: {
          args: Prisma.CampusTestimonialDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>
        }
        update: {
          args: Prisma.CampusTestimonialUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>
        }
        deleteMany: {
          args: Prisma.CampusTestimonialDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampusTestimonialUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampusTestimonialUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>[]
        }
        upsert: {
          args: Prisma.CampusTestimonialUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusTestimonialPayload>
        }
        aggregate: {
          args: Prisma.CampusTestimonialAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampusTestimonial>
        }
        groupBy: {
          args: Prisma.CampusTestimonialGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusTestimonialGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampusTestimonialCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusTestimonialCountAggregateOutputType> | number
        }
      }
    }
    CampusStory: {
      payload: Prisma.$CampusStoryPayload<ExtArgs>
      fields: Prisma.CampusStoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampusStoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampusStoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>
        }
        findFirst: {
          args: Prisma.CampusStoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampusStoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>
        }
        findMany: {
          args: Prisma.CampusStoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>[]
        }
        create: {
          args: Prisma.CampusStoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>
        }
        createMany: {
          args: Prisma.CampusStoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampusStoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>[]
        }
        delete: {
          args: Prisma.CampusStoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>
        }
        update: {
          args: Prisma.CampusStoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>
        }
        deleteMany: {
          args: Prisma.CampusStoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampusStoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampusStoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>[]
        }
        upsert: {
          args: Prisma.CampusStoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusStoryPayload>
        }
        aggregate: {
          args: Prisma.CampusStoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampusStory>
        }
        groupBy: {
          args: Prisma.CampusStoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusStoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampusStoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusStoryCountAggregateOutputType> | number
        }
      }
    }
    ProgramReview: {
      payload: Prisma.$ProgramReviewPayload<ExtArgs>
      fields: Prisma.ProgramReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>
        }
        findFirst: {
          args: Prisma.ProgramReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>
        }
        findMany: {
          args: Prisma.ProgramReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>[]
        }
        create: {
          args: Prisma.ProgramReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>
        }
        createMany: {
          args: Prisma.ProgramReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>[]
        }
        delete: {
          args: Prisma.ProgramReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>
        }
        update: {
          args: Prisma.ProgramReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>
        }
        deleteMany: {
          args: Prisma.ProgramReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>[]
        }
        upsert: {
          args: Prisma.ProgramReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramReviewPayload>
        }
        aggregate: {
          args: Prisma.ProgramReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramReview>
        }
        groupBy: {
          args: Prisma.ProgramReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramReviewCountAggregateOutputType> | number
        }
      }
    }
    ProgramTestimonial: {
      payload: Prisma.$ProgramTestimonialPayload<ExtArgs>
      fields: Prisma.ProgramTestimonialFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramTestimonialFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramTestimonialFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>
        }
        findFirst: {
          args: Prisma.ProgramTestimonialFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramTestimonialFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>
        }
        findMany: {
          args: Prisma.ProgramTestimonialFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>[]
        }
        create: {
          args: Prisma.ProgramTestimonialCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>
        }
        createMany: {
          args: Prisma.ProgramTestimonialCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramTestimonialCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>[]
        }
        delete: {
          args: Prisma.ProgramTestimonialDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>
        }
        update: {
          args: Prisma.ProgramTestimonialUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>
        }
        deleteMany: {
          args: Prisma.ProgramTestimonialDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramTestimonialUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramTestimonialUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>[]
        }
        upsert: {
          args: Prisma.ProgramTestimonialUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTestimonialPayload>
        }
        aggregate: {
          args: Prisma.ProgramTestimonialAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramTestimonial>
        }
        groupBy: {
          args: Prisma.ProgramTestimonialGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTestimonialGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramTestimonialCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTestimonialCountAggregateOutputType> | number
        }
      }
    }
    ProgramStory: {
      payload: Prisma.$ProgramStoryPayload<ExtArgs>
      fields: Prisma.ProgramStoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramStoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramStoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>
        }
        findFirst: {
          args: Prisma.ProgramStoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramStoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>
        }
        findMany: {
          args: Prisma.ProgramStoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>[]
        }
        create: {
          args: Prisma.ProgramStoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>
        }
        createMany: {
          args: Prisma.ProgramStoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramStoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>[]
        }
        delete: {
          args: Prisma.ProgramStoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>
        }
        update: {
          args: Prisma.ProgramStoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>
        }
        deleteMany: {
          args: Prisma.ProgramStoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramStoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramStoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>[]
        }
        upsert: {
          args: Prisma.ProgramStoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramStoryPayload>
        }
        aggregate: {
          args: Prisma.ProgramStoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramStory>
        }
        groupBy: {
          args: Prisma.ProgramStoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramStoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramStoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramStoryCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ProspectiveRehabsScalarFieldEnum = {
  id: 'id',
  npi_number: 'npi_number',
  organization_name: 'organization_name',
  address: 'address',
  city: 'city',
  state: 'state',
  postal_code: 'postal_code',
  phone: 'phone',
  taxonomy_code: 'taxonomy_code',
  taxonomy_desc: 'taxonomy_desc',
  last_updated: 'last_updated',
  ingested: 'ingested'
} as const

export type ProspectiveRehabsScalarFieldEnum = (typeof ProspectiveRehabsScalarFieldEnum)[keyof typeof ProspectiveRehabsScalarFieldEnum]


export const InsuranceProviderScalarFieldEnum = {
  id: 'id',
  payer_code: 'payer_code',
  payer_name: 'payer_name',
  display_name: 'display_name',
  type: 'type',
  eligibility: 'eligibility'
} as const

export type InsuranceProviderScalarFieldEnum = (typeof InsuranceProviderScalarFieldEnum)[keyof typeof InsuranceProviderScalarFieldEnum]


export const ParentCompanyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  websiteUrl: 'websiteUrl',
  description: 'description',
  verifiedExists: 'verifiedExists',
  headquartersStreet: 'headquartersStreet',
  headquartersCity: 'headquartersCity',
  headquartersState: 'headquartersState',
  headquartersPostalCode: 'headquartersPostalCode',
  headquartersCountry: 'headquartersCountry',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ParentCompanyScalarFieldEnum = (typeof ParentCompanyScalarFieldEnum)[keyof typeof ParentCompanyScalarFieldEnum]


export const YoutubeChannelScalarFieldEnum = {
  id: 'id',
  url: 'url',
  parentCompanyId: 'parentCompanyId',
  rehabOrgId: 'rehabOrgId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type YoutubeChannelScalarFieldEnum = (typeof YoutubeChannelScalarFieldEnum)[keyof typeof YoutubeChannelScalarFieldEnum]


export const YoutubeVideoScalarFieldEnum = {
  id: 'id',
  channelId: 'channelId',
  title: 'title',
  url: 'url',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type YoutubeVideoScalarFieldEnum = (typeof YoutubeVideoScalarFieldEnum)[keyof typeof YoutubeVideoScalarFieldEnum]


export const SocialMediaProfileScalarFieldEnum = {
  id: 'id',
  platform: 'platform',
  url: 'url',
  parentCompanyId: 'parentCompanyId',
  rehabOrgId: 'rehabOrgId',
  rehabCampusId: 'rehabCampusId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SocialMediaProfileScalarFieldEnum = (typeof SocialMediaProfileScalarFieldEnum)[keyof typeof SocialMediaProfileScalarFieldEnum]


export const RehabOrgScalarFieldEnum = {
  id: 'id',
  parentCompanyId: 'parentCompanyId',
  state: 'state',
  city: 'city',
  zip: 'zip',
  country: 'country',
  name: 'name',
  slug: 'slug',
  legalName: 'legalName',
  npi_number: 'npi_number',
  description: 'description',
  tagline: 'tagline',
  websiteUrl: 'websiteUrl',
  mainPhone: 'mainPhone',
  mainEmail: 'mainEmail',
  yearFounded: 'yearFounded',
  isNonProfit: 'isNonProfit',
  verifiedExists: 'verifiedExists',
  primarySourceUrl: 'primarySourceUrl',
  otherSourceUrls: 'otherSourceUrls',
  baseCurrency: 'baseCurrency',
  fullPrivatePrice: 'fullPrivatePrice',
  defaultTimeZone: 'defaultTimeZone',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabOrgScalarFieldEnum = (typeof RehabOrgScalarFieldEnum)[keyof typeof RehabOrgScalarFieldEnum]


export const RehabCampusScalarFieldEnum = {
  id: 'id',
  rehabOrgId: 'rehabOrgId',
  name: 'name',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description',
  street: 'street',
  city: 'city',
  state: 'state',
  postalCode: 'postalCode',
  country: 'country',
  latitude: 'latitude',
  longitude: 'longitude',
  phone: 'phone',
  email: 'email',
  timeZone: 'timeZone',
  visitingHours: 'visitingHours',
  directionsSummary: 'directionsSummary',
  bedsTotal: 'bedsTotal',
  bedsDetox: 'bedsDetox',
  bedsResidential: 'bedsResidential',
  bedsOutpatientCapacity: 'bedsOutpatientCapacity',
  acceptsWalkIns: 'acceptsWalkIns',
  hasOnsiteMD: 'hasOnsiteMD',
  hasTwentyFourHourNursing: 'hasTwentyFourHourNursing',
  primaryEnvironmentId: 'primaryEnvironmentId',
  primarySettingStyleId: 'primarySettingStyleId',
  primaryLuxuryTierId: 'primaryLuxuryTierId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabCampusScalarFieldEnum = (typeof RehabCampusScalarFieldEnum)[keyof typeof RehabCampusScalarFieldEnum]


export const RehabProgramScalarFieldEnum = {
  id: 'id',
  campusId: 'campusId',
  levelOfCareId: 'levelOfCareId',
  name: 'name',
  slug: 'slug',
  shortName: 'shortName',
  description: 'description',
  targetPopulationSummary: 'targetPopulationSummary',
  clinicalFocusSummary: 'clinicalFocusSummary',
  minLengthOfStayDays: 'minLengthOfStayDays',
  maxLengthOfStayDays: 'maxLengthOfStayDays',
  typicalLengthOfStayDays: 'typicalLengthOfStayDays',
  sessionScheduleSummary: 'sessionScheduleSummary',
  checkInDays: 'checkInDays',
  intakePhone: 'intakePhone',
  intakeEmail: 'intakeEmail',
  isDetoxPrimary: 'isDetoxPrimary',
  isMATProgram: 'isMATProgram',
  hasOnsiteMD: 'hasOnsiteMD',
  hasTwentyFourHourNursing: 'hasTwentyFourHourNursing',
  staffToPatientRatio: 'staffToPatientRatio',
  acceptsSelfReferral: 'acceptsSelfReferral',
  acceptsCourtOrdered: 'acceptsCourtOrdered',
  acceptsMedicallyComplex: 'acceptsMedicallyComplex',
  waitlistCategory: 'waitlistCategory',
  waitlistDescription: 'waitlistDescription',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabProgramScalarFieldEnum = (typeof RehabProgramScalarFieldEnum)[keyof typeof RehabProgramScalarFieldEnum]


export const LevelOfCareScalarFieldEnum = {
  id: 'id',
  type: 'type',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type LevelOfCareScalarFieldEnum = (typeof LevelOfCareScalarFieldEnum)[keyof typeof LevelOfCareScalarFieldEnum]


export const DetoxServiceScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type DetoxServiceScalarFieldEnum = (typeof DetoxServiceScalarFieldEnum)[keyof typeof DetoxServiceScalarFieldEnum]


export const MATTypeScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  medicationClass: 'medicationClass',
  description: 'description'
} as const

export type MATTypeScalarFieldEnum = (typeof MATTypeScalarFieldEnum)[keyof typeof MATTypeScalarFieldEnum]


export const ServiceScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


export const PopulationScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type PopulationScalarFieldEnum = (typeof PopulationScalarFieldEnum)[keyof typeof PopulationScalarFieldEnum]


export const AccreditationScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type AccreditationScalarFieldEnum = (typeof AccreditationScalarFieldEnum)[keyof typeof AccreditationScalarFieldEnum]


export const LanguageScalarFieldEnum = {
  id: 'id',
  code: 'code',
  displayName: 'displayName',
  description: 'description'
} as const

export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


export const AmenityScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


export const EnvironmentScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type EnvironmentScalarFieldEnum = (typeof EnvironmentScalarFieldEnum)[keyof typeof EnvironmentScalarFieldEnum]


export const SettingStyleScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type SettingStyleScalarFieldEnum = (typeof SettingStyleScalarFieldEnum)[keyof typeof SettingStyleScalarFieldEnum]


export const LuxuryTierScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  rank: 'rank',
  description: 'description'
} as const

export type LuxuryTierScalarFieldEnum = (typeof LuxuryTierScalarFieldEnum)[keyof typeof LuxuryTierScalarFieldEnum]


export const ProgramFeatureScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type ProgramFeatureScalarFieldEnum = (typeof ProgramFeatureScalarFieldEnum)[keyof typeof ProgramFeatureScalarFieldEnum]


export const PaymentOptionScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description'
} as const

export type PaymentOptionScalarFieldEnum = (typeof PaymentOptionScalarFieldEnum)[keyof typeof PaymentOptionScalarFieldEnum]


export const InsurancePayerScalarFieldEnum = {
  id: 'id',
  companyName: 'companyName',
  slug: 'slug',
  displayName: 'displayName',
  description: 'description',
  payerType: 'payerType'
} as const

export type InsurancePayerScalarFieldEnum = (typeof InsurancePayerScalarFieldEnum)[keyof typeof InsurancePayerScalarFieldEnum]


export const SubstanceScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  displayName: 'displayName',
  category: 'category',
  description: 'description'
} as const

export type SubstanceScalarFieldEnum = (typeof SubstanceScalarFieldEnum)[keyof typeof SubstanceScalarFieldEnum]


export const RehabLevelOfCareScalarFieldEnum = {
  rehabId: 'rehabId',
  levelOfCareId: 'levelOfCareId'
} as const

export type RehabLevelOfCareScalarFieldEnum = (typeof RehabLevelOfCareScalarFieldEnum)[keyof typeof RehabLevelOfCareScalarFieldEnum]


export const RehabDetoxServiceScalarFieldEnum = {
  rehabId: 'rehabId',
  detoxServiceId: 'detoxServiceId'
} as const

export type RehabDetoxServiceScalarFieldEnum = (typeof RehabDetoxServiceScalarFieldEnum)[keyof typeof RehabDetoxServiceScalarFieldEnum]


export const RehabServiceScalarFieldEnum = {
  rehabId: 'rehabId',
  serviceId: 'serviceId'
} as const

export type RehabServiceScalarFieldEnum = (typeof RehabServiceScalarFieldEnum)[keyof typeof RehabServiceScalarFieldEnum]


export const RehabPopulationScalarFieldEnum = {
  rehabId: 'rehabId',
  populationId: 'populationId'
} as const

export type RehabPopulationScalarFieldEnum = (typeof RehabPopulationScalarFieldEnum)[keyof typeof RehabPopulationScalarFieldEnum]


export const RehabAccreditationScalarFieldEnum = {
  rehabId: 'rehabId',
  accreditationId: 'accreditationId'
} as const

export type RehabAccreditationScalarFieldEnum = (typeof RehabAccreditationScalarFieldEnum)[keyof typeof RehabAccreditationScalarFieldEnum]


export const RehabLanguageScalarFieldEnum = {
  rehabId: 'rehabId',
  languageId: 'languageId'
} as const

export type RehabLanguageScalarFieldEnum = (typeof RehabLanguageScalarFieldEnum)[keyof typeof RehabLanguageScalarFieldEnum]


export const RehabAmenityScalarFieldEnum = {
  rehabId: 'rehabId',
  amenityId: 'amenityId'
} as const

export type RehabAmenityScalarFieldEnum = (typeof RehabAmenityScalarFieldEnum)[keyof typeof RehabAmenityScalarFieldEnum]


export const RehabEnvironmentScalarFieldEnum = {
  rehabId: 'rehabId',
  environmentId: 'environmentId'
} as const

export type RehabEnvironmentScalarFieldEnum = (typeof RehabEnvironmentScalarFieldEnum)[keyof typeof RehabEnvironmentScalarFieldEnum]


export const RehabSettingStyleScalarFieldEnum = {
  rehabId: 'rehabId',
  settingStyleId: 'settingStyleId'
} as const

export type RehabSettingStyleScalarFieldEnum = (typeof RehabSettingStyleScalarFieldEnum)[keyof typeof RehabSettingStyleScalarFieldEnum]


export const RehabLuxuryTierScalarFieldEnum = {
  rehabId: 'rehabId',
  luxuryTierId: 'luxuryTierId'
} as const

export type RehabLuxuryTierScalarFieldEnum = (typeof RehabLuxuryTierScalarFieldEnum)[keyof typeof RehabLuxuryTierScalarFieldEnum]


export const RehabProgramFeatureGlobalScalarFieldEnum = {
  rehabId: 'rehabId',
  programFeatureId: 'programFeatureId'
} as const

export type RehabProgramFeatureGlobalScalarFieldEnum = (typeof RehabProgramFeatureGlobalScalarFieldEnum)[keyof typeof RehabProgramFeatureGlobalScalarFieldEnum]


export const RehabCampusAmenityScalarFieldEnum = {
  campusId: 'campusId',
  amenityId: 'amenityId'
} as const

export type RehabCampusAmenityScalarFieldEnum = (typeof RehabCampusAmenityScalarFieldEnum)[keyof typeof RehabCampusAmenityScalarFieldEnum]


export const RehabCampusLanguageScalarFieldEnum = {
  campusId: 'campusId',
  languageId: 'languageId'
} as const

export type RehabCampusLanguageScalarFieldEnum = (typeof RehabCampusLanguageScalarFieldEnum)[keyof typeof RehabCampusLanguageScalarFieldEnum]


export const RehabCampusPopulationScalarFieldEnum = {
  campusId: 'campusId',
  populationId: 'populationId'
} as const

export type RehabCampusPopulationScalarFieldEnum = (typeof RehabCampusPopulationScalarFieldEnum)[keyof typeof RehabCampusPopulationScalarFieldEnum]


export const RehabCampusEnvironmentScalarFieldEnum = {
  campusId: 'campusId',
  environmentId: 'environmentId'
} as const

export type RehabCampusEnvironmentScalarFieldEnum = (typeof RehabCampusEnvironmentScalarFieldEnum)[keyof typeof RehabCampusEnvironmentScalarFieldEnum]


export const RehabCampusSettingStyleScalarFieldEnum = {
  campusId: 'campusId',
  settingStyleId: 'settingStyleId'
} as const

export type RehabCampusSettingStyleScalarFieldEnum = (typeof RehabCampusSettingStyleScalarFieldEnum)[keyof typeof RehabCampusSettingStyleScalarFieldEnum]


export const RehabCampusLuxuryTierScalarFieldEnum = {
  campusId: 'campusId',
  luxuryTierId: 'luxuryTierId'
} as const

export type RehabCampusLuxuryTierScalarFieldEnum = (typeof RehabCampusLuxuryTierScalarFieldEnum)[keyof typeof RehabCampusLuxuryTierScalarFieldEnum]


export const RehabProgramDetoxServiceScalarFieldEnum = {
  programId: 'programId',
  detoxServiceId: 'detoxServiceId'
} as const

export type RehabProgramDetoxServiceScalarFieldEnum = (typeof RehabProgramDetoxServiceScalarFieldEnum)[keyof typeof RehabProgramDetoxServiceScalarFieldEnum]


export const RehabProgramMATTypeScalarFieldEnum = {
  programId: 'programId',
  matTypeId: 'matTypeId'
} as const

export type RehabProgramMATTypeScalarFieldEnum = (typeof RehabProgramMATTypeScalarFieldEnum)[keyof typeof RehabProgramMATTypeScalarFieldEnum]


export const RehabProgramServiceScalarFieldEnum = {
  programId: 'programId',
  serviceId: 'serviceId'
} as const

export type RehabProgramServiceScalarFieldEnum = (typeof RehabProgramServiceScalarFieldEnum)[keyof typeof RehabProgramServiceScalarFieldEnum]


export const RehabProgramPopulationScalarFieldEnum = {
  programId: 'programId',
  populationId: 'populationId'
} as const

export type RehabProgramPopulationScalarFieldEnum = (typeof RehabProgramPopulationScalarFieldEnum)[keyof typeof RehabProgramPopulationScalarFieldEnum]


export const RehabProgramLanguageScalarFieldEnum = {
  programId: 'programId',
  languageId: 'languageId'
} as const

export type RehabProgramLanguageScalarFieldEnum = (typeof RehabProgramLanguageScalarFieldEnum)[keyof typeof RehabProgramLanguageScalarFieldEnum]


export const RehabProgramAmenityScalarFieldEnum = {
  programId: 'programId',
  amenityId: 'amenityId'
} as const

export type RehabProgramAmenityScalarFieldEnum = (typeof RehabProgramAmenityScalarFieldEnum)[keyof typeof RehabProgramAmenityScalarFieldEnum]


export const RehabProgramFeatureScalarFieldEnum = {
  programId: 'programId',
  programFeatureId: 'programFeatureId'
} as const

export type RehabProgramFeatureScalarFieldEnum = (typeof RehabProgramFeatureScalarFieldEnum)[keyof typeof RehabProgramFeatureScalarFieldEnum]


export const RehabProgramSubstanceScalarFieldEnum = {
  programId: 'programId',
  substanceId: 'substanceId'
} as const

export type RehabProgramSubstanceScalarFieldEnum = (typeof RehabProgramSubstanceScalarFieldEnum)[keyof typeof RehabProgramSubstanceScalarFieldEnum]


export const RehabInsurancePayerScalarFieldEnum = {
  id: 'id',
  rehabId: 'rehabId',
  campusId: 'campusId',
  programId: 'programId',
  insurancePayerId: 'insurancePayerId',
  scope: 'scope',
  networkStatus: 'networkStatus',
  averageAdmissionPrice: 'averageAdmissionPrice',
  estimatedPatientOopMin: 'estimatedPatientOopMin',
  estimatedPatientOopMax: 'estimatedPatientOopMax',
  requiresPreauth: 'requiresPreauth',
  acceptsOutOfNetworkWithOopCap: 'acceptsOutOfNetworkWithOopCap',
  notes: 'notes',
  overview: 'overview',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabInsurancePayerScalarFieldEnum = (typeof RehabInsurancePayerScalarFieldEnum)[keyof typeof RehabInsurancePayerScalarFieldEnum]


export const RehabPaymentOptionScalarFieldEnum = {
  id: 'id',
  rehabId: 'rehabId',
  campusId: 'campusId',
  programId: 'programId',
  paymentOptionId: 'paymentOptionId',
  descriptionOverride: 'descriptionOverride',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RehabPaymentOptionScalarFieldEnum = (typeof RehabPaymentOptionScalarFieldEnum)[keyof typeof RehabPaymentOptionScalarFieldEnum]


export const OrgReviewScalarFieldEnum = {
  id: 'id',
  rehabOrgId: 'rehabOrgId',
  rating: 'rating',
  title: 'title',
  body: 'body',
  reviewerType: 'reviewerType',
  reviewerName: 'reviewerName',
  reviewerRole: 'reviewerRole',
  source: 'source',
  externalUrl: 'externalUrl',
  isFeatured: 'isFeatured',
  isVerified: 'isVerified',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrgReviewScalarFieldEnum = (typeof OrgReviewScalarFieldEnum)[keyof typeof OrgReviewScalarFieldEnum]


export const OrgTestimonialScalarFieldEnum = {
  id: 'id',
  rehabOrgId: 'rehabOrgId',
  quote: 'quote',
  attributionName: 'attributionName',
  attributionRole: 'attributionRole',
  source: 'source',
  isFeatured: 'isFeatured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrgTestimonialScalarFieldEnum = (typeof OrgTestimonialScalarFieldEnum)[keyof typeof OrgTestimonialScalarFieldEnum]


export const OrgStoryScalarFieldEnum = {
  id: 'id',
  rehabOrgId: 'rehabOrgId',
  storyType: 'storyType',
  title: 'title',
  slug: 'slug',
  summary: 'summary',
  body: 'body',
  tags: 'tags',
  isPublic: 'isPublic',
  isFeatured: 'isFeatured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrgStoryScalarFieldEnum = (typeof OrgStoryScalarFieldEnum)[keyof typeof OrgStoryScalarFieldEnum]


export const CampusReviewScalarFieldEnum = {
  id: 'id',
  campusId: 'campusId',
  rating: 'rating',
  title: 'title',
  body: 'body',
  reviewerType: 'reviewerType',
  reviewerName: 'reviewerName',
  reviewerRole: 'reviewerRole',
  source: 'source',
  externalUrl: 'externalUrl',
  isFeatured: 'isFeatured',
  isVerified: 'isVerified',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampusReviewScalarFieldEnum = (typeof CampusReviewScalarFieldEnum)[keyof typeof CampusReviewScalarFieldEnum]


export const CampusTestimonialScalarFieldEnum = {
  id: 'id',
  campusId: 'campusId',
  quote: 'quote',
  attributionName: 'attributionName',
  attributionRole: 'attributionRole',
  source: 'source',
  isFeatured: 'isFeatured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampusTestimonialScalarFieldEnum = (typeof CampusTestimonialScalarFieldEnum)[keyof typeof CampusTestimonialScalarFieldEnum]


export const CampusStoryScalarFieldEnum = {
  id: 'id',
  campusId: 'campusId',
  storyType: 'storyType',
  title: 'title',
  slug: 'slug',
  summary: 'summary',
  body: 'body',
  tags: 'tags',
  isPublic: 'isPublic',
  isFeatured: 'isFeatured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampusStoryScalarFieldEnum = (typeof CampusStoryScalarFieldEnum)[keyof typeof CampusStoryScalarFieldEnum]


export const ProgramReviewScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  rating: 'rating',
  title: 'title',
  body: 'body',
  reviewerType: 'reviewerType',
  reviewerName: 'reviewerName',
  reviewerRole: 'reviewerRole',
  source: 'source',
  externalUrl: 'externalUrl',
  isFeatured: 'isFeatured',
  isVerified: 'isVerified',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProgramReviewScalarFieldEnum = (typeof ProgramReviewScalarFieldEnum)[keyof typeof ProgramReviewScalarFieldEnum]


export const ProgramTestimonialScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  quote: 'quote',
  attributionName: 'attributionName',
  attributionRole: 'attributionRole',
  source: 'source',
  isFeatured: 'isFeatured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProgramTestimonialScalarFieldEnum = (typeof ProgramTestimonialScalarFieldEnum)[keyof typeof ProgramTestimonialScalarFieldEnum]


export const ProgramStoryScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  storyType: 'storyType',
  title: 'title',
  slug: 'slug',
  summary: 'summary',
  body: 'body',
  tags: 'tags',
  isPublic: 'isPublic',
  isFeatured: 'isFeatured',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProgramStoryScalarFieldEnum = (typeof ProgramStoryScalarFieldEnum)[keyof typeof ProgramStoryScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'WaitlistCategory'
 */
export type EnumWaitlistCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WaitlistCategory'>
    


/**
 * Reference to a field of type 'WaitlistCategory[]'
 */
export type ListEnumWaitlistCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WaitlistCategory[]'>
    


/**
 * Reference to a field of type 'LevelOfCareType'
 */
export type EnumLevelOfCareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LevelOfCareType'>
    


/**
 * Reference to a field of type 'LevelOfCareType[]'
 */
export type ListEnumLevelOfCareTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LevelOfCareType[]'>
    


/**
 * Reference to a field of type 'InsuranceScope'
 */
export type EnumInsuranceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceScope'>
    


/**
 * Reference to a field of type 'InsuranceScope[]'
 */
export type ListEnumInsuranceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceScope[]'>
    


/**
 * Reference to a field of type 'NetworkStatus'
 */
export type EnumNetworkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NetworkStatus'>
    


/**
 * Reference to a field of type 'NetworkStatus[]'
 */
export type ListEnumNetworkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NetworkStatus[]'>
    


/**
 * Reference to a field of type 'ReviewerType'
 */
export type EnumReviewerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewerType'>
    


/**
 * Reference to a field of type 'ReviewerType[]'
 */
export type ListEnumReviewerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewerType[]'>
    


/**
 * Reference to a field of type 'ReviewSource'
 */
export type EnumReviewSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewSource'>
    


/**
 * Reference to a field of type 'ReviewSource[]'
 */
export type ListEnumReviewSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewSource[]'>
    


/**
 * Reference to a field of type 'StoryType'
 */
export type EnumStoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryType'>
    


/**
 * Reference to a field of type 'StoryType[]'
 */
export type ListEnumStoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryType[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  prospectiveRehabs?: Prisma.ProspectiveRehabsOmit
  insuranceProvider?: Prisma.InsuranceProviderOmit
  parentCompany?: Prisma.ParentCompanyOmit
  youtubeChannel?: Prisma.YoutubeChannelOmit
  youtubeVideo?: Prisma.YoutubeVideoOmit
  socialMediaProfile?: Prisma.SocialMediaProfileOmit
  rehabOrg?: Prisma.RehabOrgOmit
  rehabCampus?: Prisma.RehabCampusOmit
  rehabProgram?: Prisma.RehabProgramOmit
  levelOfCare?: Prisma.LevelOfCareOmit
  detoxService?: Prisma.DetoxServiceOmit
  mATType?: Prisma.MATTypeOmit
  service?: Prisma.ServiceOmit
  population?: Prisma.PopulationOmit
  accreditation?: Prisma.AccreditationOmit
  language?: Prisma.LanguageOmit
  amenity?: Prisma.AmenityOmit
  environment?: Prisma.EnvironmentOmit
  settingStyle?: Prisma.SettingStyleOmit
  luxuryTier?: Prisma.LuxuryTierOmit
  programFeature?: Prisma.ProgramFeatureOmit
  paymentOption?: Prisma.PaymentOptionOmit
  insurancePayer?: Prisma.InsurancePayerOmit
  substance?: Prisma.SubstanceOmit
  rehabLevelOfCare?: Prisma.RehabLevelOfCareOmit
  rehabDetoxService?: Prisma.RehabDetoxServiceOmit
  rehabService?: Prisma.RehabServiceOmit
  rehabPopulation?: Prisma.RehabPopulationOmit
  rehabAccreditation?: Prisma.RehabAccreditationOmit
  rehabLanguage?: Prisma.RehabLanguageOmit
  rehabAmenity?: Prisma.RehabAmenityOmit
  rehabEnvironment?: Prisma.RehabEnvironmentOmit
  rehabSettingStyle?: Prisma.RehabSettingStyleOmit
  rehabLuxuryTier?: Prisma.RehabLuxuryTierOmit
  rehabProgramFeatureGlobal?: Prisma.RehabProgramFeatureGlobalOmit
  rehabCampusAmenity?: Prisma.RehabCampusAmenityOmit
  rehabCampusLanguage?: Prisma.RehabCampusLanguageOmit
  rehabCampusPopulation?: Prisma.RehabCampusPopulationOmit
  rehabCampusEnvironment?: Prisma.RehabCampusEnvironmentOmit
  rehabCampusSettingStyle?: Prisma.RehabCampusSettingStyleOmit
  rehabCampusLuxuryTier?: Prisma.RehabCampusLuxuryTierOmit
  rehabProgramDetoxService?: Prisma.RehabProgramDetoxServiceOmit
  rehabProgramMATType?: Prisma.RehabProgramMATTypeOmit
  rehabProgramService?: Prisma.RehabProgramServiceOmit
  rehabProgramPopulation?: Prisma.RehabProgramPopulationOmit
  rehabProgramLanguage?: Prisma.RehabProgramLanguageOmit
  rehabProgramAmenity?: Prisma.RehabProgramAmenityOmit
  rehabProgramFeature?: Prisma.RehabProgramFeatureOmit
  rehabProgramSubstance?: Prisma.RehabProgramSubstanceOmit
  rehabInsurancePayer?: Prisma.RehabInsurancePayerOmit
  rehabPaymentOption?: Prisma.RehabPaymentOptionOmit
  orgReview?: Prisma.OrgReviewOmit
  orgTestimonial?: Prisma.OrgTestimonialOmit
  orgStory?: Prisma.OrgStoryOmit
  campusReview?: Prisma.CampusReviewOmit
  campusTestimonial?: Prisma.CampusTestimonialOmit
  campusStory?: Prisma.CampusStoryOmit
  programReview?: Prisma.ProgramReviewOmit
  programTestimonial?: Prisma.ProgramTestimonialOmit
  programStory?: Prisma.ProgramStoryOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

